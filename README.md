# Домашнее задание к занятию "`Резервное копирование.`" - `Барышков Михаил`

## Задание 1. Резервное копирование

### Кейс

Финансовая компания решила увеличить надёжность работы баз данных и их резервного копирования.

Необходимо описать, какие варианты резервного копирования подходят в случаях:

1.1. Необходимо восстанавливать данные в полном объёме за предыдущий день.

1.2. Необходимо восстанавливать данные за час до предполагаемой поломки.

1.3.* Возможен ли кейс, когда при поломке базы происходило моментальное переключение на работающую или починенную базу данных.

*Приведите ответ в свободной форме.*

---

## Решение 1

1.1. **Восстановление данных в полном объёме за предыдущий день**

Подходит **полное резервное копирование (Full Backup)**, выполняемое ежедневно.

- **Плюсы**: Простота восстановления, так как все данные хранятся в одной резервной копии.
- **Минусы**: Требует больше места и времени по сравнению с другими методами.

*Альтернатива*: Можно использовать **дифференциальное резервное копирование (Differential Backup)**, если полный бэкап делается реже (например, раз в неделю), а дифференциальные — ежедневно (содержат все изменения с момента последнего Full Backup).

---

1.2. **Восстановление данных за час до поломки**

Подходит **инкрементное резервное копирование (Incremental Backup)** с частыми интервалами (например, каждый час).

- **Плюсы**: Экономит место и время, так как сохраняются только изменения с последнего бэкапа.
- **Минусы**: Восстановление сложнее, так как требует цепочки всех инкрементных копий с момента последнего Full Backup.

### Дополнительно

- Можно комбинировать **Full + Incremental** (например, полный бэкап раз в сутки + инкрементный каждый час).
- **Транзакционные логи (Transaction Log Backup)** в СУБД (например, SQL Server, PostgreSQL) позволяют восстановить базу до конкретного момента времени.

---

1.3. **Моментальное переключение на работающую базу при поломке**

Да, такое возможно с помощью **репликации (Replication)** и **отказоустойчивых кластеров (Failover Clusters)**.

**Варианты реализации:**

1. **Master-Slave репликация:**

- При падении основной базы (Master) можно вручную или автоматически переключиться на реплику (Slave).
- Примеры: MySQL Replication, PostgreSQL Streaming Replication.

2. **Автоматический Failover (High Availability, HA):**

- Используется кластерная настройка (например, **PostgreSQL с Patroni, MongoDB Replica Set, SQL Server AlwaysOn**).
- При отказе основной ноды кластер автоматически переключается на standby-ноду.

3. **Распределённые СУБД (например, Cassandra, CockroachDB):**

- Данные автоматически реплицируются между узлами, отказ одного узла не приводит к потере доступности.

### Требования:

- Настроенный мониторинг (например, **Prometheus + Alertmanager**).
- Минимальное время восстановления (RTO) и минимизация потерь данных (RPO).

### Вывод

- Для **полного восстановления за день** — Full или Differential Backup.
- Для **восстановления за час** — Incremental Backup или транзакционные логи.
- Для **мгновенного переключения** — репликация или отказоустойчивые кластеры.

Выбор метода зависит от критичности данных, бюджета и допустимого времени простоя.

---

## Задание 2. PostgreSQL

2.1. С помощью официальной документации приведите пример команды резервирования данных и восстановления БД (pgdump/pgrestore).

2.1.* Возможно ли автоматизировать этот процесс? Если да, то как?

*Приведите ответ в свободной форме.*

---

## Решение 2

2.1. Резервное копирование и восстановление в PostgreSQL

### Резервное копирование (pg_dump)

Команда `pg_dump` создаёт дамп базы данных в SQL-формате или в бинарном (архивном) формате.

**Пример 1: Дамп в SQL-формате**

```bash
pg_dump -U username -d dbname -f backup.sql
```

- `-U username` — пользователь PostgreSQL.

- `-d dbname` — имя базы данных.

- `-f backup.sql` — сохранить дамп в файл.

**Пример 2: Дамп в бинарном формате (для pg_restore)**

```bash
pg_dump -U username -d dbname -F c -f backup.dump
```

- `-F c` — формат "custom" (бинарный, сжатый).

**Восстановление (pg_restore)**

Если использовался бинарный формат (`-F c`), восстановление выполняется через `pg_restore`.

### Пример 1: Восстановление в новую БД

``` bash
pg_restore -U username -d new_dbname -C backup.dump
```

- `-C`— создаёт новую базу данных перед восстановлением.

### Пример 2: Восстановление в существующую БД

```bash
pg_restore -U username -d existing_dbname backup.dump
```

**Если дамп был в SQL-формате**, можно восстановить через psql:

```bash
psql -U username -d dbname -f backup.sql
```

2.1. **Автоматизация резервного копирования**
Да, процесс можно автоматизировать несколькими способами:

1. **Cron + скрипт**
Пример скрипта (backup_postgres.sh):

```bash
#!/bin/bash
DATE=$(date +%Y-%m-%d_%H-%M)
pg_dump -U username -d dbname -F c -f /backups/dbname_$DATE.dump
find /backups -type f -mtime +7 -delete  # Удаляем старые бэкапы (старше 7 дней)
```

Добавляем в `crontab -e`:

```bash
0 2 * * * /path/to/backup_postgres.sh  # Каждый день в 2:00
```

2. Использование утилиты `pg_back` или `barman`

- **pgBackRest** — мощное решение для инкрементных и полных бэкапов.
- **Barman** (Backup and Recovery Manager) — специализированный инструмент для PostgreSQL.

3. **Репликация + WAL-архивирование**

- Настройка **WAL-архивирования** (`archive_mode = on`) позволяет восстанавливать базу до любого момента времени (Point-in-Time Recovery, PITR).
- Комбинация **физических бэкапов + WAL-логи** даёт максимальную надёжность.

### Вывод

- **Резервное копирование**: `pg_dump` (SQL или бинарный формат).
- **Восстановление**: `pg_restore` (для бинарного формата) или psql (для SQL).
- **Автоматизация**: Cron, pgBackRest, Barman или WAL-архивирование.

Для прода лучше использовать **pgBackRest/Barman + WAL**, так как это даёт возможность:

- Инкрементных бэкапов.
- Восстановления на определённый момент времени.
- Автоматического управления бэкапами.

## Задание 3. MySQL

3.1. С помощью официальной документации приведите пример команды инкрементного резервного копирования базы данных MySQL.

3.1.* В каких случаях использование реплики будет давать преимущество по сравнению с обычным резервным копированием?

*Приведите ответ в свободной форме.*

---

## Решение 3

3.1. **Инкрементное резервное копирование в MySQL**

В MySQL инкрементное резервное копирование обычно выполняется с использованием **бинарных логов (binary logs)**, которые содержат все изменения данных (INSERT, UPDATE, DELETE и т. д.).

### Шаг 1. Включение бинарного лога

Проверьте, что в `my.cnf/my.ini` включены бинарные логи:

```ini
[mysqld]
log-bin = mysql-bin  # Включает бинарное логгирование
server-id = 1        # Уникальный ID сервера (для репликации)
```

После изменения конфига перезапустите MySQL:

```bash
sudo systemctl restart mysql
```

### Шаг 2. Полное резервное копирование (Full Backup)

Сначала делаем полный бэкап (основа для инкрементных):

```bash
mysqldump -u root -p --flush-logs --master-data=2 --single-transaction --databases mydb > full_backup.sql
```

- `--flush-logs` — закрывает текущий бинарный лог и начинает новый.
- `--master-data=2` — записывает позицию бинарного лога в дамп (нужно для восстановления).
- `--single-transaction` — обеспечивает консистентность данных (для InnoDB).

### Шаг 3. Инкрементное копирование (из бинарных логов)

После полного бэкапа можно делать инкрементные, извлекая изменения из бинарных логов:

```bash
mysqlbinlog --start-position=XXXX mysql-bin.00000N > incremental_backup.sql
```

- `--start-position=XXXX` — позиция из `full_backup.sql` (или последнего инкрементного бэкапа).
- `mysql-bin.00000N` — имя бинарного лога, где хранятся изменения.

### Шаг 4. Восстановление

Восстанавливаем полный бэкап:

```bash
mysql -u root -p < full_backup.sql
```

Применяем инкрементные изменения:

```bash
mysql -u root -p < incremental_backup.sql
```

3.1. **Преимущества реплики перед обычным бэкапом***

Репликация (Master-Slave) даёт следующие преимущества:

1. **Минимальное время простоя (High Availability)**

- При падении Master можно быстро переключиться на Slave (вручную или автоматически, с помощью Orchestrator или ProxySQL).
- В то время как восстановление из бэкапа может занять минуты или часы.

2. **Горячее резервирование (Live Backup)**

- Реплика постоянно синхронизируется с мастером, данные почти всегда актуальны.
- Обычный бэкап — это "снимок" на момент времени, возможна потеря данных.

3. **Масштабирование чтения**

- Реплики могут использоваться для **распределения нагрузки** (SELECT-запросы можно направлять на Slave).
- Обычный бэкап не может использоваться для запросов.

4. **Point-in-Time Recovery (PITR) без остановки**

- Если мастер "умер", можно восстановить данные из реплики + бинарных логов.
- В случае бэкапа нужно останавливать сервер или блокировать таблицы.

### Когда репликация НЕ заменяет бэкап?

- Ошибки на мастере (например, `DROP DATABASE`) мгновенно реплицируются на Slave.
- Атаки или повреждение данных требуют "чистого" бэкапа.

### Вывод

- **Инкрементный бэкап в MySQL** делается через *бинарные логи** (`mysqlbinlog`).

- **Репликация** лучше обычного бэкапа для:

  - Отказоустойчивости (HA).
  - Минимального RTO (время восстановления).
  - Распределения нагрузки.

- **Но бэкапы всё равно** нужны для защиты от логических ошибок и катастрофических сбоев.

## Рекомендуемая стратегия:

**Репликация (Master-Slave) + Регулярные полные/инкрементные бэкапы + Хранение бинарных логов**.

Задания, помеченные звёздочкой, — дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже шире разобраться в материале.
